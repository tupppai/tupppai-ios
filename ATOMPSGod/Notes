1.先是life cycle，然后是Delegate方法实现，然后是event response，然后才是getters and setters。这样后来者阅读代码时就能省力很多。

2.但我还是建议尽量不要通过继承的方案来给原生对象添加功能，前面提到的Aspect方案和Category方案都可以使用。用Aspect＋load来实现重载函数，用Category来实现添加函数，当然，耍点手段用Category来添加property也是没问题的。这些方案已经覆盖了继承的全部功能，而且非常好维护，对于业务方也更加透明，何乐而不为呢。
3.Hugging => content does not want to grow
Compression Resistance => content does not want to shrink


//
//  MRAFNetworkingSupportViewController.m
//  Example
//
//  Created by Marius Rackwitz on 16.07.14.
//  Copyright (c) 2014 Marius Rackwitz. All rights reserved.
//

#import "MRAFNetworkingSupportViewController.h"
#import "AFNetworking.h"
#import "MRActivityIndicatorView.h"
#import "MRCircularProgressView.h"
#import "MRNavigationBarProgressView.h"
#import "MRActivityIndicatorView+AFNetworking.h"
#import "MRProgressView+AFNetworking.h"
#import "MRProgressOverlayView+AFNetworking.h"


@interface MRAFNetworkingSupportViewController ()

@property (weak, nonatomic) IBOutlet MRActivityIndicatorView *activityIndicatorView;
@property (weak, nonatomic) IBOutlet MRCircularProgressView *circularProgressView;

@property (nonatomic, strong) AFHTTPSessionManager *sessionManager;

@end


@implementation MRAFNetworkingSupportViewController

- (void)viewDidLoad {
[super viewDidLoad];

self.activityIndicatorView.hidesWhenStopped = NO;

NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
config.requestCachePolicy = NSURLRequestReloadIgnoringCacheData;

AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@"https://httpbin.org/"] sessionConfiguration:config];
sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];
self.sessionManager = sessionManager;
}

- (NSURLSessionDownloadTask *)bytesDownloadTask {
NSProgress *downloadProgress = nil;
NSURLSessionDownloadTask *task = [self.sessionManager downloadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"/bytes/1000000" relativeToURL:self.sessionManager.baseURL]]
progress:&downloadProgress
destination:nil
completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error){
NSLog(@"Task completed with error: %@", error);
}];
[task resume];
return task;
}


- (IBAction)onNavigationBarProgressViewGo:(id)sender {
NSURLSessionDownloadTask *task = [self bytesDownloadTask];
[[MRNavigationBarProgressView progressViewForNavigationController:self.navigationController]
setProgressWithDownloadProgressOfTask:task animated:YES];
}

@end
